diff -u -r -N gcc-7.3.0/gcc/config/sh/constraints.md gcc-7.3.0_patch/gcc/config/sh/constraints.md
--- gcc-7.3.0/gcc/config/sh/constraints.md	2017-01-01 13:07:43.000000000 +0100
+++ gcc-7.3.0_patch/gcc/config/sh/constraints.md	2018-12-28 22:06:13.064860849 +0100
@@ -62,6 +62,9 @@
 (define_register_constraint "a" "ALL_REGS"
   "@internal")
 
+(define_register_constraint "b" "TARGET_REGS"
+  "Branch target registers.")
+
 (define_register_constraint "c" "FPSCR_REGS"
   "Floating-point status register.")
 
diff -u -r -N gcc-7.3.0/gcc/config/sh/elf.h gcc-7.3.0_patch/gcc/config/sh/elf.h
--- gcc-7.3.0/gcc/config/sh/elf.h	2017-01-01 13:07:43.000000000 +0100
+++ gcc-7.3.0_patch/gcc/config/sh/elf.h	2018-12-28 22:07:10.617432819 +0100
@@ -72,7 +72,7 @@
 
 #undef STARTFILE_SPEC
 #define STARTFILE_SPEC \
-  "%{!shared: crt1.o%s} crti.o%s \
+  "%{!shared: crt1.o%s trap-handler.o%s} crti.o%s \
    %{!shared:crtbegin.o%s} %{shared:crtbeginS.o%s}"
 
 #undef ENDFILE_SPEC
diff -u -r -N gcc-7.3.0/gcc/config/sh/embed-elf.h gcc-7.3.0_patch/gcc/config/sh/embed-elf.h
--- gcc-7.3.0/gcc/config/sh/embed-elf.h	2017-01-01 13:07:43.000000000 +0100
+++ gcc-7.3.0_patch/gcc/config/sh/embed-elf.h	2018-12-28 22:10:17.255223220 +0100
@@ -22,6 +22,10 @@
 #undef USER_LABEL_PREFIX
 #define USER_LABEL_PREFIX "_"
 
+/* builtin_trap can use trapa.  */
+#undef TARGET_BUILTIN_TRAPA
+#define TARGET_BUILTIN_TRAPA 1
+
 /* While the speed-optimized implementations of udivsi3_i4i / sdivsi3_i4i
    in libgcc are not available for SH2, the space-optimized ones in
    libgcc-Os-4-200 are.  Thus, when not optimizing for space, link
diff -u -r -N gcc-7.3.0/gcc/config/sh/linux.h gcc-7.3.0_patch/gcc/config/sh/linux.h
--- gcc-7.3.0/gcc/config/sh/linux.h	2017-01-01 13:07:43.000000000 +0100
+++ gcc-7.3.0_patch/gcc/config/sh/linux.h	2018-12-28 22:14:41.245633516 +0100
@@ -28,7 +28,7 @@
 #define SUBTARGET_CPP_SPEC "\
    %{posix:-D_POSIX_SOURCE} \
    %{pthread:-D_REENTRANT -D_PTHREADS} \
-"
+   %{m4-300*:-D__SH4_300__} "
 
 #define TARGET_OS_CPP_BUILTINS() \
   do						\
@@ -136,5 +143,9 @@
       /* Set -musermode if it hasn't been specified.  */		\
       if (global_options_set.x_TARGET_USERMODE == 0)			\
 	TARGET_USERMODE = true;						\
+      /* Don't emit DWARF3/4 unless specifically selected.  The ST40    \
+	 debuggers do not yet support DWARF 3/4.  */                    \
+      if (!global_options_set.x_dwarf_version)                          \
+         dwarf_version = 3;                                             \
     }									\
   while (0)				\
diff -u -r -N gcc-7.3.0/gcc/config/sh/sh.c gcc-7.3.0_patch/gcc/config/sh/sh.c
--- gcc-7.3.0/gcc/config/sh/sh.c	2017-04-04 00:30:56.000000000 +0200
+++ gcc-7.3.0_patch/gcc/config/sh/sh.c	2018-12-28 21:44:31.091550573 +0100
@@ -752,6 +752,102 @@
 #undef err_ret
 }
 
+/* Information on the currently selected __builtin_trap handler.  */
+static sh_builtin_trap_handler selected_builtin_trap_handler_;
+
+const sh_builtin_trap_handler&
+selected_builtin_trap_handler (void)
+{
+  return selected_builtin_trap_handler_;
+}
+
+static sh_builtin_trap_handler
+parse_validate_builtin_trap_option (const char* str)
+{
+  const char* names[sh_builtin_trap_handler::num_handlers];
+  names[sh_builtin_trap_handler::none] = "none";
+  names[sh_builtin_trap_handler::libcall] = "libcall";
+  names[sh_builtin_trap_handler::trapa] = "trapa";
+
+  sh_builtin_trap_handler ret;
+
+  #if defined (SH_BUILTIN_TRAP_DEFAULT_TRAPA)
+    #if SH_BUILTIN_TRAP_DEFAULT_TRAPA < 0 || SH_BUILTIN_TRAP_DEFAULT_TRAPA > 255
+      #error default builtin trap trapa handler value out of range
+    #endif
+    ret.type = sh_builtin_trap_handler::trapa;
+    ret.trapa_imm_val = SH_BUILTIN_TRAP_DEFAULT_TRAPA;
+  #elif defined (SH_BUILTIN_TRAP_DEFAULT_LIBCALL)
+    ret.type = sh_builtin_trap_handler::libcall;
+    ret.trapa_imm_val = 0;
+  #else
+    ret.type = sh_builtin_trap_handler::none;
+    ret.trapa_imm_val = 0;
+  #endif
+
+  /* Handle empty string as 'none'.  */
+  if (str == NULL || *str == '\0')
+    return ret;
+
+#define err_ret(...) do { error (__VA_ARGS__); return ret; } while (0)
+
+  std::vector<std::string> tokens;
+  for (std::stringstream ss (str); ss.good (); )
+  {
+    tokens.push_back (std::string ());
+    std::getline (ss, tokens.back (), ',');
+  }
+
+  if (tokens.empty ())
+    err_ret ("invalid builtin trap handler option");
+
+  /* The first token must be the handler name.  */
+  {
+    for (size_t i = 0; i < sh_builtin_trap_handler::num_handlers; ++i)
+      if (tokens.front () == names[i])
+	{
+	  ret.type = (sh_builtin_trap_handler::enum_type)i;
+	  goto got_mode_name;
+	}
+
+    err_ret ("invalid builtin trap handler name \"%s\"",
+	     tokens.front ().c_str ());
+got_mode_name:;
+  }
+
+  /* Go through the remaining tokens.  */
+  bool have_imm = false;
+
+  for (size_t i = 1; i < tokens.size (); ++i)
+    {
+      if (tokens[i].find ("imm=") == 0)
+	{
+	  have_imm = true;
+	  std::string imm_str = tokens[i].substr (strlen ("imm="));
+	  ret.trapa_imm_val = integral_argument (imm_str.c_str ());
+	  if (imm_str.empty () || ret.trapa_imm_val == -1)
+	    err_ret ("could not parse imm value \"%s\" in builtin trap handler "
+		     "option", imm_str.c_str ());
+	}
+      else
+	err_ret ("unknown parameter \"%s\" in builtin trap handler option",
+		 tokens[i].c_str ());
+    }
+
+  /* Check that the selection makes sense.  */
+  if (ret.type == sh_builtin_trap_handler::trapa && have_imm == false)
+    err_ret ("immediate value not specified for trapa builtin trap handler");
+
+  if (ret.type == sh_builtin_trap_handler::trapa
+      && (ret.trapa_imm_val < 0 || ret.trapa_imm_val > 255))
+    err_ret ("immediate value for trapa builtin trap handler must be in the "
+	     "range 0-255");
+
+  return ret;
+
+#undef err_ret
+}
+
 /* Register SH specific RTL passes.  */
 extern opt_pass* make_pass_sh_treg_combine (gcc::context* ctx, bool split_insns,
 					    const char* name);
@@ -967,6 +1063,10 @@
   selected_atomic_model_
     = parse_validate_atomic_model_option (sh_atomic_model_str);
 
+  /* Parse __builtin_trap handler option.  */
+  selected_builtin_trap_handler_
+    = parse_validate_builtin_trap_option (sh_builtin_trap_handler_str);
+
   register_sh_passes ();
 }
 
diff -u -r -N gcc-7.3.0/gcc/config/sh/sh-c.c gcc-7.3.0_patch/gcc/config/sh/sh-c.c
--- gcc-7.3.0/gcc/config/sh/sh-c.c	2017-01-01 13:07:43.000000000 +0100
+++ gcc-7.3.0_patch/gcc/config/sh/sh-c.c	2018-12-28 22:20:59.881860074 +0100
@@ -139,4 +143,7 @@
 
   cpp_define_formatted (pfile, "__SH_ATOMIC_MODEL_%s__",
 			selected_atomic_model ().cdef_name);
+
+  if (TARGET_SH4_TRAPA_SLEEP_BUG)
+    builtin_define ("__SH4_TRAPA_SLEEP_BUG__");
 }
diff -u -r -N gcc-7.3.0/gcc/config/sh/sh.h gcc-7.3.0_patch/gcc/config/sh/sh.h
--- gcc-7.3.0/gcc/config/sh/sh.h	2017-01-01 13:07:43.000000000 +0100
+++ gcc-7.3.0_patch/gcc/config/sh/sh.h	2018-12-28 22:40:33.894259161 +0100
@@ -31,6 +31,19 @@
 
 #define TARGET_CPU_CPP_BUILTINS() sh_cpu_cpp_builtins (pfile)
 
+/* Target CPU builtins for D.  */
+#define TARGET_CPU_D_BUILTINS()			\
+  do						\
+    {						\
+      builtin_define ("SH");			\
+						\
+      if (TARGET_FPU_ANY)			\
+	builtin_define ("D_HardFloat");		\
+      else					\
+	builtin_define ("D_SoftFloat");		\
+    }						\
+  while (0)
+
 /* Value should be nonzero if functions must have frame pointers.
    Zero means the frame pointer need not be set up (and parms may be accessed
    via the stack pointer) in functions that seem suitable.  */
@@ -76,7 +89,7 @@
    && ! (TARGET_HITACHI || sh_attr_renesas_p (FUN_DECL)))
 
 #ifndef TARGET_CPU_DEFAULT
-#define TARGET_CPU_DEFAULT SELECT_SH1
+#define TARGET_CPU_DEFAULT SELECT_SH4
 #define SUPPORT_SH1 1
 #define SUPPORT_SH2E 1
 #define SUPPORT_SH4 1
@@ -85,9 +98,23 @@
 #define SUPPORT_SH2A_SINGLE 1
 #endif
 
+#define TARGET_DIVIDE_INV \
+  (sh_div_strategy == SH_DIV_INV || sh_div_strategy == SH_DIV_INV_MINLAT \
+   || sh_div_strategy == SH_DIV_INV20U || sh_div_strategy == SH_DIV_INV20L \
+   || sh_div_strategy == SH_DIV_INV_CALL \
+   || sh_div_strategy == SH_DIV_INV_CALL2 || sh_div_strategy == SH_DIV_INV_FP)
+#define TARGET_DIVIDE_FP (sh_div_strategy == SH_DIV_FP)
+#define TARGET_DIVIDE_INV_FP (sh_div_strategy == SH_DIV_INV_FP)
+#define TARGET_DIVIDE_INV_MINLAT (sh_div_strategy == SH_DIV_INV_MINLAT)
+#define TARGET_DIVIDE_INV20U (sh_div_strategy == SH_DIV_INV20U)
+#define TARGET_DIVIDE_INV20L (sh_div_strategy == SH_DIV_INV20L)
+#define TARGET_DIVIDE_INV_CALL (sh_div_strategy == SH_DIV_INV_CALL)
+#define TARGET_DIVIDE_INV_CALL2 (sh_div_strategy == SH_DIV_INV_CALL2)
 #define TARGET_DIVIDE_CALL_DIV1 (sh_div_strategy == SH_DIV_CALL_DIV1)
 #define TARGET_DIVIDE_CALL_FP (sh_div_strategy == SH_DIV_CALL_FP)
-#define TARGET_DIVIDE_CALL_TABLE (sh_div_strategy == SH_DIV_CALL_TABLE)
+#define TARGET_DIVIDE_CALL_PRE1 (sh_div_strategy == SH_DIV_CALL_PRE1)
+#define TARGET_DIVIDE_CALL_TABLE (sh_div_strategy == SH_DIV_CALL_TABLE \
+   || TARGET_DIVIDE_CALL_PRE1)
 
 #define SELECT_SH1		 (MASK_SH1)
 #define SELECT_SH2		 (MASK_SH2 | SELECT_SH1)
@@ -252,7 +280,11 @@
  "%{m4-nofpu:-isa=sh4-nofpu} " ASM_ISA_DEFAULT_SPEC
 #endif
 #else /* ! STRICT_NOFPU */
-#define SUBTARGET_ASM_ISA_SPEC ASM_ISA_DEFAULT_SPEC
+#define SUBTARGET_ASM_ISA_SPEC "%{m4-nofpu:--isa=sh4-nofpu-up} \
+ %{m4|m4-single*:--isa=sh4-up} \
+ %{m4-300-nofpu:--isa=st40-300-nofpu} \
+ %{m4-300|m4-300-single|m4-300-single-only:--isa=st40-300}" \
+ ASM_ISA_DEFAULT_SPEC
 #endif
 
 #ifndef SUBTARGET_ASM_SPEC
@@ -265,6 +297,13 @@
 #define LINK_EMUL_PREFIX "sh%{ml:l}"
 #endif
 
+#if TARGET_CPU_DEFAULT & MASK_SH4
+#define ASM_ISA_SPEC_DEFAULT "--isa=sh4-up"
+#define ASM_ISA_DEFAULT_SPEC \
+" %{!m1:%{!m2*:%{!m3*:%{!m4*:%{!m5*:" ASM_ISA_SPEC_DEFAULT "}}}}}"
+#else /* !MASK_SH4 */
+#define ASM_ISA_DEFAULT_SPEC ""
+#endif
 #define LINK_DEFAULT_CPU_EMUL ""
 #define ASM_ISA_DEFAULT_SPEC ""
 
@@ -278,6 +317,8 @@
 -m %(link_emul_prefix)\
 %{!m1:%{!m2:%{!m3*:%{!m4*:%(link_default_cpu_emul)}}}}\
 %(subtarget_link_emul_suffix) \
+%{mdb-page-bug:--db-page-bug} \
+%{shared:-shared} \
 %{mrelax:-relax} %(subtarget_link_spec)"
 
 #ifndef SH_DIV_STR_FOR_SIZE
@@ -324,6 +365,7 @@
   SH_DIV_CALL_DIV1, /* No FPU, medium size, highest latency.  */
   SH_DIV_CALL_FP,     /* FPU needed, small size, high latency.  */
   SH_DIV_CALL_TABLE,  /* No FPU, large size, medium latency. */
+  SH_DIV_CALL_PRE1,  /* Preheader to optimize return 1 cases. */
   SH_DIV_INTRINSIC
 };
 
diff -u -r -N gcc-7.3.0/gcc/config/sh/sh.md gcc-7.3.0_patch/gcc/config/sh/sh.md
--- gcc-7.3.0/gcc/config/sh/sh.md	2017-11-23 15:08:12.000000000 +0100
+++ gcc-7.3.0_patch/gcc/config/sh/sh.md	2018-12-28 22:43:00.595655585 +0100
@@ -42,6 +42,8 @@
 ;;    l -- pr
 ;;    z -- r0
 ;;
+;;    R03 -- r0, r1, r2 or r3  - experimental constraint for SH4-300
+;;
 ;; Special formats used for outputting SH instructions:
 ;;
 ;;   %.  --  print a .s if insn needs delay slot
@@ -8902,6 +8904,55 @@
 ;; Misc
 ;; -------------------------------------------------------------------------
 
+;; __builtin_trap
+(define_expand "trap"
+  [(trap_if (const_int 1) (const_int 0))]
+  "TARGET_SH1 && !TARGET_BUILTIN_TRAP_NONE"
+{
+  if (TARGET_BUILTIN_TRAP_TRAPA)
+    emit_insn (gen_trapa (TARGET_BUILTIN_TRAP_TRAPA_VAL_RTX));
+  else if (TARGET_BUILTIN_TRAP_LIBCALL)
+    {
+      rtx funcaddr = gen_reg_rtx (Pmode);
+      rtx lab = function_symbol (funcaddr, "__builtin_trap", SFUNC_STATIC).lab;
+      emit_insn (gen_trap_call (funcaddr, lab));
+    }
+  else
+    gcc_unreachable ();
+
+  DONE;
+})
+
+(define_insn "trapa"
+  [(trap_if (const_int 1) (match_operand:SI 0 "const_logical_operand"))]
+  "TARGET_SH1"
+{
+  if (TARGET_SH4_TRAPA_SLEEP_BUG)
+    return     "trapa	%0"	"\n"
+	   "	or	r0,r0"	"\n"
+	   "	or	r0,r0"	"\n"
+	   "	or	r0,r0"	"\n"
+	   "	or	r0,r0"	"\n"
+	   "	or	r0,r0";
+  else
+    return "trapa	%0";
+}
+  [(set (attr "length") (if_then_else (match_test "TARGET_SH4_TRAPA_SLEEP_BUG")
+				      (const_int 12) (const_int 2)))
+   (set_attr "in_delay_slot" "no")])
+
+(define_insn "trap_call"
+  [(trap_if (const_int 1) (const_int 0))
+   (use (match_operand:SI 0 "arith_reg_operand" "r,r"))
+   (use (match_operand:SI 1 "" "Z,Ccl"))
+   (clobber (reg:SI PR_REG))]
+  "TARGET_SH1"
+  "@
+	jsr	@%0%#
+	bsrf	%0\n%01:%#"
+  [(set_attr "type" "sfunc")
+   (set_attr "needs_delay_slot" "yes")])
+
 ;; String/block move insn.
 
 (define_expand "movmemsi"
diff -u -r -N gcc-7.3.0/gcc/config/sh/sh-mem.cc gcc-7.3.0_patch/gcc/config/sh/sh-mem.cc
--- gcc-7.3.0/gcc/config/sh/sh-mem.cc	2017-08-16 01:43:11.000000000 +0200
+++ gcc-7.3.0_patch/gcc/config/sh/sh-mem.cc	2018-12-28 22:23:02.139359768 +0100
@@ -56,6 +56,89 @@
   if (! constp)
     return false;
 
+  if ((TARGET_SH4 || TARGET_SH2A_DOUBLE)
+      && TARGET_FMOVD
+      && !optimize_size && align == 8 && bytes > 4)
+  {
+      rtx dest = copy_rtx (operands[0]);
+      rtx src = copy_rtx (operands[1]);
+      rtx src_addr = copy_addr_to_reg (XEXP (src, 0));
+
+      int copied = 0;
+
+      while (copied + 48 <= bytes)
+	{
+	  rtx temp0 = gen_reg_rtx (DFmode);
+	  rtx temp1 = gen_reg_rtx (DFmode);
+	  rtx temp2 = gen_reg_rtx (DFmode);
+	  rtx temp3 = gen_reg_rtx (DFmode);
+	  rtx temp4 = gen_reg_rtx (DFmode);
+	  rtx temp5 = gen_reg_rtx (DFmode);
+
+	  rtx to0 = adjust_address (dest, DFmode, copied);
+	  rtx to1 = adjust_address (dest, DFmode, copied+8);
+	  rtx to2 = adjust_address (dest, DFmode, copied+16);
+	  rtx to3 = adjust_address (dest, DFmode, copied+24);
+	  rtx to4 = adjust_address (dest, DFmode, copied+32);
+	  rtx to5 = adjust_address (dest, DFmode, copied+40);
+
+	  rtx from0 = adjust_automodify_address (src, DFmode, src_addr, copied);
+	  rtx from1 = adjust_automodify_address (src, DFmode, src_addr, copied + 8);
+	  rtx from2 = adjust_automodify_address (src, DFmode, src_addr, copied + 16);
+	  rtx from3 = adjust_automodify_address (src, DFmode, src_addr, copied + 24);
+	  rtx from4 = adjust_automodify_address (src, DFmode, src_addr, copied + 32);
+	  rtx from5 = adjust_automodify_address (src, DFmode, src_addr, copied + 40);
+
+	  emit_move_insn (temp0, from0);
+	  emit_move_insn (src_addr, plus_constant (Pmode, src_addr, 8));
+
+	  emit_move_insn (temp1, from1);
+	  emit_move_insn (src_addr, plus_constant (Pmode, src_addr, 8));
+
+	  emit_move_insn (temp2, from2);
+	  emit_move_insn (src_addr, plus_constant (Pmode, src_addr, 8));
+
+	  emit_move_insn (temp3, from3);
+	  emit_move_insn (src_addr, plus_constant (Pmode, src_addr, 8));
+
+	  emit_move_insn (temp4, from4);
+	  emit_move_insn (src_addr, plus_constant (Pmode, src_addr, 8));
+
+	  emit_move_insn (temp5, from5);
+	  emit_move_insn (src_addr, plus_constant (Pmode, src_addr, 8));
+
+	  emit_move_insn (to0, temp0);
+	  emit_move_insn (to1, temp1);
+	  emit_move_insn (to2, temp2);
+	  emit_move_insn (to3, temp3);
+	  emit_move_insn (to4, temp4);
+	  emit_move_insn (to5, temp5);
+
+	  copied += 48;
+	}
+
+      while (copied + 8 <= bytes)
+	{
+	  rtx temp0 = gen_reg_rtx (DFmode);
+	  rtx to0 = adjust_address (dest, DFmode, copied);
+	  rtx from0 = adjust_automodify_address (src, DFmode, src_addr, copied);
+
+	  emit_move_insn (temp0, from0);
+	  emit_move_insn (src_addr, plus_constant (Pmode, src_addr, 8));
+	  emit_move_insn (to0, temp0);
+	  copied += 8;
+	}
+
+      if (copied < bytes)
+	move_by_pieces (adjust_address (dest, BLKmode, copied),
+			adjust_automodify_address (src, BLKmode,
+						   src_addr, copied),
+			bytes - copied, align, 0);
+
+      return true;
+  }
+
+
   /* If we could use mov.l to move words and dest is word-aligned, we
      can use movua.l for loads and still generate a relatively short
      and efficient sequence.  */
diff -u -r -N gcc-7.3.0/gcc/config/sh/sh.opt gcc-7.3.0_patch/gcc/config/sh/sh.opt
--- gcc-7.3.0/gcc/config/sh/sh.opt	2017-01-01 13:07:43.000000000 +0100
+++ gcc-7.3.0_patch/gcc/config/sh/sh.opt	2018-12-28 22:45:22.072991852 +0100
@@ -260,6 +260,10 @@
 Target Report RejectNegative Mask(PREFERGOT)
 Emit function-calls using global offset table when generating PIC.
 
+mr0r3-to-reg-mul
+Target Var(TARGET_R0R3_TO_REG_MUL, 2) Init(-1)
+Assume availability of integer multiply instruction (src only opd in r0-r3)
+
 mrelax
 Target Report RejectNegative Mask(RELAX)
 Shorten address references during linking.
@@ -301,3 +305,11 @@
 mlra
 Target Report Var(sh_lra_flag) Init(0) Save
 Use LRA instead of reload (transitional).
+
+msh4-trapa-sleep-bug
+Target Report Var(sh4_trapa_sleep_bug_option) Init(-1)
+Handle the trapa/sleep/undefined instruction 0xFFFD bug.
+
+mbuiltin-trap=
+Target Report RejectNegative Joined Var(sh_builtin_trap_handler_str)
+Specify what code to emit for __builtin_trap.
diff -u -r -N gcc-7.3.0/gcc/config/sh/sh-protos.h gcc-7.3.0_patch/gcc/config/sh/sh-protos.h
--- gcc-7.3.0/gcc/config/sh/sh-protos.h	2017-01-01 13:07:43.000000000 +0100
+++ gcc-7.3.0_patch/gcc/config/sh/sh-protos.h	2018-12-28 21:44:31.087550450 +0100
@@ -35,6 +35,46 @@
   SFUNC_STATIC
 };
 
+/* __builtin_trapa handling options.  */
+struct sh_builtin_trap_handler
+{
+  enum enum_type
+  {
+    none = 0,
+    libcall,
+    trapa,
+
+    num_handlers
+  };
+
+  enum_type type;
+  int trapa_imm_val;
+};
+
+extern const sh_builtin_trap_handler& selected_builtin_trap_handler (void);
+
+#define TARGET_BUILTIN_TRAP_NONE \
+  (selected_builtin_trap_handler ().type == sh_builtin_trap_handler::none)
+
+#define TARGET_BUILTIN_TRAP_TRAPA \
+  (selected_builtin_trap_handler ().type == sh_builtin_trap_handler::trapa)
+
+#define TARGET_BUILTIN_TRAP_TRAPA_VAL_RTX \
+  GEN_INT (selected_builtin_trap_handler ().trapa_imm_val)
+
+#define TARGET_BUILTIN_TRAP_LIBCALL \
+  (selected_builtin_trap_handler ().type == sh_builtin_trap_handler::libcall)
+
+#ifdef SH4_TRAPA_SLEEP_BUG_DEFAULT
+#define TARGET_SH4_TRAPA_SLEEP_BUG \
+  (sh4_trapa_sleep_bug_option == -1 ? (SH4_TRAPA_SLEEP_BUG_DEFAULT != 0) \
+  				    : (sh4_trapa_sleep_bug_option != 0))
+#else
+#define TARGET_SH4_TRAPA_SLEEP_BUG \
+  ((sh4_trapa_sleep_bug_option == -1 && TARGET_SH4 && !TARGET_SH4A) \
+   || sh4_trapa_sleep_bug_option == 1)
+#endif
+
 #ifdef RTX_CODE
 extern rtx sh_fsca_sf2int (void);
 extern rtx sh_fsca_int2sf (void);
diff -u -r -N gcc-7.3.0/gcc/config/sh/superh.h gcc-7.3.0_patch/gcc/config/sh/superh.h
--- gcc-7.3.0/gcc/config/sh/superh.h	2017-01-09 22:48:33.000000000 +0100
+++ gcc-7.3.0_patch/gcc/config/sh/superh.h	2018-12-28 22:46:19.497531906 +0100
@@ -101,4 +101,15 @@
   "%{!shared: %{!m4-400*:%{!m4-340*: %{pg:gcrt1-mmu.o%s}%{!pg:crt1-mmu.o%s}}}} \
    %{!shared: %{m4-340*|m4-400*: %{pg:gcrt1.o%s}%{!pg:crt1.o%s}}} \
    crti.o%s \
-   %{!shared:crtbegin.o%s} %{shared:crtbeginS.o%s}"
+   %{!shared:crtbegin.o%s trap-handler.o%s} %{shared:crtbeginS.o%s}"
+
+#undef SUBTARGET_OVERRIDE_OPTIONS
+#define SUBTARGET_OVERRIDE_OPTIONS					\
+  do									\
+    {									\
+      /* Don't emit DWARF3/4 unless specifically selected.  The ST40    \
+	 debuggers do not yet support DWARF 3/4.  */                    \
+      if (!global_options_set.x_dwarf_version)                          \
+         dwarf_version = 3;                                             \
+    }									\
+  while (0)
diff -u -r -N gcc-7.3.0/gcc/config/sh/t-sh64 gcc-7.3.0_patch/gcc/config/sh/t-sh64
--- gcc-7.3.0/gcc/config/sh/t-sh64	1970-01-01 01:00:00.000000000 +0100
+++ gcc-7.3.0_patch/gcc/config/sh/t-sh64	2013-01-10 21:38:27.000000000 +0100
@@ -0,0 +1,22 @@
+# Copyright (C) 2002-2013 Free Software Foundation, Inc.
+#
+# This file is part of GCC.
+#
+# GCC is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3, or (at your option)
+# any later version.
+#
+# GCC is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GCC; see the file COPYING3.  If not see
+# <http://www.gnu.org/licenses/>.
+
+MULTILIB_CPU_DIRS= $(ML_sh1) $(ML_sh2e) $(ML_sh2) $(ML_sh3e) $(ML_sh3) $(ML_sh4_nofpu) $(ML_sh4_single_only) $(ML_sh4_single) $(ML_sh4) $(ML_sh5_32media:m5-32media/=media32) $(ML_sh5_32media_nofpu:m5-32media-nofpu/=nofpu/media32) $(ML_sh5_compact:m5-compact/=compact) $(ML_sh5_compact_nofpu:m5-compact-nofpu/=nofpu/compact) $(ML_sh5_64media:m5-64media/=media64) $(ML_sh5_64media_nofpu:m5-64media-nofpu/=nofpu/media64)
+
+MULTILIB_RAW_DIRNAMES= $(MULTILIB_ENDIAN:/mb= mb) $(MULTILIB_CPU_DIRS:/=)
+MULTILIB_DIRNAMES= $(MULTILIB_RAW_DIRNAMES)
diff -u -r -N gcc-7.3.0/gcc/config/sh/ushmedia.h gcc-7.3.0_patch/gcc/config/sh/ushmedia.h
--- gcc-7.3.0/gcc/config/sh/ushmedia.h	1970-01-01 01:00:00.000000000 +0100
+++ gcc-7.3.0_patch/gcc/config/sh/ushmedia.h	2013-02-03 21:06:01.000000000 +0100
@@ -0,0 +1,1091 @@
+/* Copyright (C) 2000-2013 Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+Under Section 7 of GPL version 3, you are granted additional
+permissions described in the GCC Runtime Library Exception, version
+3.1, as published by the Free Software Foundation.
+
+You should have received a copy of the GNU General Public License and
+a copy of the GCC Runtime Library Exception along with this program;
+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+<http://www.gnu.org/licenses/>.  */
+
+
+/* ushmedia.h: Intrinsics corresponding to SHmedia instructions that
+   may be executed in both user and privileged mode.  */
+
+#ifndef _USHMEDIA_H
+#define _USHMEDIA_H
+
+#if __SHMEDIA__
+#if ! __SH4_NO_FPU
+typedef float __GCC_FV __attribute__ ((vector_size (4 * sizeof (float))));
+typedef float __GCC_MTRX __attribute__ ((vector_size (16 * sizeof (float))));
+#endif
+
+static __inline unsigned long long
+sh_media_MABS_L (unsigned long long mm)
+{
+  typedef float v2si __attribute__ ((mode(V2SI)));
+
+  return (unsigned long long) __builtin_absv2si2 ((v2si) mm);
+}
+
+static __inline unsigned long long
+sh_media_MABS_W (unsigned long long mm)
+{
+  typedef float v4hi __attribute__ ((mode(V4HI)));
+
+  return (unsigned long long) __builtin_absv4hi2 ((v4hi) mm);
+}
+
+static __inline unsigned long long
+sh_media_MADD_L (unsigned long long mm, unsigned long long mn)
+{
+  typedef float v2si __attribute__ ((mode(V2SI)));
+
+  return (unsigned long long) __builtin_addv2si3 ((v2si) mm, (v2si) mn);
+}
+
+static __inline unsigned long long
+sh_media_MADD_W (unsigned long long mm, unsigned long long mn)
+{
+  typedef float v4hi __attribute__ ((mode(V4HI)));
+
+  return (unsigned long long) __builtin_addv4hi3 ((v4hi) mm, (v4hi) mn);
+}
+
+static __inline unsigned long long
+sh_media_MADDS_L (unsigned long long mm, unsigned long long mn)
+{
+  typedef float v2si __attribute__ ((mode(V2SI)));
+
+  return (unsigned long long) __builtin_ssaddv2si3 ((v2si) mm, (v2si) mn);
+}
+
+static __inline unsigned long long
+sh_media_MADDS_UB (unsigned long long mm, unsigned long long mn)
+{
+  typedef float v8qi __attribute__ ((mode(V8QI)));
+
+  return (unsigned long long) __builtin_usaddv8qi3 ((v8qi) mm, (v8qi) mn);
+}
+
+static __inline unsigned long long
+sh_media_MADDS_W (unsigned long long mm, unsigned long long mn)
+{
+  typedef float v4hi __attribute__ ((mode(V4HI)));
+
+  return (unsigned long long) __builtin_ssaddv4hi3 ((v4hi) mm, (v4hi) mn);
+}
+
+static __inline unsigned long long
+sh_media_MCMPEQ_B (unsigned long long mm, unsigned long long mn)
+{
+  typedef float v8qi __attribute__ ((mode(V8QI)));
+
+  return (unsigned long long) __builtin_sh_media_MCMPEQ_B ((v8qi) mm,
+							   (v8qi) mn);
+}
+
+static __inline unsigned long long
+sh_media_MCMPEQ_L (unsigned long long mm, unsigned long long mn)
+{
+  typedef float v2si __attribute__ ((mode(V2SI)));
+
+  return (unsigned long long) __builtin_sh_media_MCMPEQ_L ((v2si) mm,
+							   (v2si) mn);
+}
+
+static __inline unsigned long long
+sh_media_MCMPEQ_W (unsigned long long mm, unsigned long long mn)
+{
+  typedef float v4hi __attribute__ ((mode(V4HI)));
+
+  return (unsigned long long) __builtin_sh_media_MCMPEQ_W ((v4hi) mm,
+							   (v4hi) mn);
+}
+
+static __inline unsigned long long
+sh_media_MCMPGT_UB (unsigned long long mm, unsigned long long mn)
+{
+  typedef float v8qi __attribute__ ((mode(V8QI)));
+
+  return (unsigned long long) __builtin_sh_media_MCMPGT_UB ((v8qi) mm,
+							   (v8qi) mn);
+}
+
+static __inline unsigned long long
+sh_media_MCMPGT_L (unsigned long long mm, unsigned long long mn)
+{
+  typedef float v2si __attribute__ ((mode(V2SI)));
+
+  return (unsigned long long) __builtin_sh_media_MCMPGT_L ((v2si) mm,
+							   (v2si) mn);
+}
+
+static __inline unsigned long long
+sh_media_MCMPGT_W (unsigned long long mm, unsigned long long mn)
+{
+  typedef float v4hi __attribute__ ((mode(V4HI)));
+
+  return (unsigned long long) __builtin_sh_media_MCMPGT_W ((v4hi) mm,
+							   (v4hi) mn);
+}
+
+#define sh_media_MCMV __builtin_sh_media_MCMV
+
+static __inline unsigned long long
+sh_media_MCNVS_LW (unsigned long long mm, unsigned long long mn)
+{
+  typedef float v2si __attribute__ ((mode(V2SI)));
+  typedef unsigned int uv2si __attribute__ ((mode(V2SI)));
+
+  return (unsigned long long) __builtin_sh_media_MCNVS_LW ((v2si) mm,
+							   (uv2si) mn);
+}
+
+static __inline unsigned long long
+sh_media_MCNVS_WB (unsigned long long mm, unsigned long long mn)
+{
+  typedef float v4hi __attribute__ ((mode(V4HI)));
+
+  return (unsigned long long) __builtin_sh_media_MCNVS_WB ((v4hi) mm,
+							   (v4hi) mn);
+}
+
+static __inline unsigned long long
+sh_media_MCNVS_WUB (unsigned long long mm, unsigned long long mn)
+{
+  typedef float v4hi __attribute__ ((mode(V4HI)));
+
+  return (unsigned long long) __builtin_sh_media_MCNVS_WUB ((v4hi) mm,
+							    (v4hi) mn);
+}
+
+static __inline unsigned long long
+sh_media_MEXTR1 (unsigned long long mm, unsigned long long mn)
+{
+  typedef float v8qi __attribute__ ((mode(V8QI)));
+
+  return (unsigned long long) __builtin_sh_media_MEXTR1 ((v8qi) mm,
+							 (v8qi) mn);
+}
+
+static __inline unsigned long long
+sh_media_MEXTR2 (unsigned long long mm, unsigned long long mn)
+{
+  typedef float v8qi __attribute__ ((mode(V8QI)));
+
+  return (unsigned long long) __builtin_sh_media_MEXTR2 ((v8qi) mm,
+							 (v8qi) mn);
+}
+
+static __inline unsigned long long
+sh_media_MEXTR3 (unsigned long long mm, unsigned long long mn)
+{
+  typedef float v8qi __attribute__ ((mode(V8QI)));
+
+  return (unsigned long long) __builtin_sh_media_MEXTR3 ((v8qi) mm,
+							 (v8qi) mn);
+}
+
+static __inline unsigned long long
+sh_media_MEXTR4 (unsigned long long mm, unsigned long long mn)
+{
+  typedef float v8qi __attribute__ ((mode(V8QI)));
+
+  return (unsigned long long) __builtin_sh_media_MEXTR4 ((v8qi) mm,
+							 (v8qi) mn);
+}
+
+static __inline unsigned long long
+sh_media_MEXTR5 (unsigned long long mm, unsigned long long mn)
+{
+  typedef float v8qi __attribute__ ((mode(V8QI)));
+
+  return (unsigned long long) __builtin_sh_media_MEXTR5 ((v8qi) mm,
+							 (v8qi) mn);
+}
+
+static __inline unsigned long long
+sh_media_MEXTR6 (unsigned long long mm, unsigned long long mn)
+{
+  typedef float v8qi __attribute__ ((mode(V8QI)));
+
+  return (unsigned long long) __builtin_sh_media_MEXTR6 ((v8qi) mm,
+							 (v8qi) mn);
+}
+
+static __inline unsigned long long
+sh_media_MEXTR7 (unsigned long long mm, unsigned long long mn)
+{
+  typedef float v8qi __attribute__ ((mode(V8QI)));
+
+  return (unsigned long long) __builtin_sh_media_MEXTR7 ((v8qi) mm,
+							 (v8qi) mn);
+}
+
+static __inline unsigned long long
+sh_media_MMACFX_WL (unsigned long long mm, unsigned long long mn,
+		    unsigned long long mw)
+{
+  typedef float v2hi __attribute__ ((mode(V2HI)));
+  typedef float v2si __attribute__ ((mode(V2SI)));
+  typedef unsigned int uv2si __attribute__ ((mode(V2SI)));
+
+  long mm_l = (long) mm;
+  long mn_l = (long) mn;
+
+  return ((unsigned long long)
+    __builtin_sh_media_MMACFX_WL ((v2hi) mm_l, (v2hi) mn_l,
+				  (uv2si) mw));
+}
+
+static __inline unsigned long long
+sh_media_MMACNFX_WL (unsigned long long mm, unsigned long long mn,
+		     unsigned long long mw)
+{
+  typedef float v2hi __attribute__ ((mode(V2HI)));
+  typedef float v2si __attribute__ ((mode(V2SI)));
+  typedef unsigned int uv2si __attribute__ ((mode(V2SI)));
+
+  long mm_l = (long) mm;
+  long mn_l = (long) mn;
+
+  return ((unsigned long long)
+    __builtin_sh_media_MMACNFX_WL ((v2hi) mm_l, (v2hi) mn_l,
+				   (uv2si) mw));
+}
+
+static __inline unsigned long long
+sh_media_MMUL_L (unsigned long long mm, unsigned long long mn)
+{
+  typedef float v2si __attribute__ ((mode(V2SI)));
+
+  return (unsigned long long) __builtin_mulv2si3 ((v2si) mm, (v2si) mn);
+}
+
+static __inline unsigned long long
+sh_media_MMUL_W (unsigned long long mm, unsigned long long mn)
+{
+  typedef float v4hi __attribute__ ((mode(V4HI)));
+
+  return (unsigned long long) __builtin_mulv4hi3 ((v4hi) mm, (v4hi) mn);
+}
+
+static __inline unsigned long long
+sh_media_MMULFX_L (unsigned long long mm, unsigned long long mn)
+{
+  typedef float v2si __attribute__ ((mode(V2SI)));
+
+  return (unsigned long long) __builtin_sh_media_MMULFX_L ((v2si) mm,
+							   (v2si) mn);
+}
+
+static __inline unsigned long long
+sh_media_MMULFX_W (unsigned long long mm, unsigned long long mn)
+{
+  typedef float v4hi __attribute__ ((mode(V4HI)));
+
+  return (unsigned long long) __builtin_sh_media_MMULFX_W ((v4hi) mm,
+							   (v4hi) mn);
+}
+
+static __inline unsigned long long
+sh_media_MMULFXRP_W (unsigned long long mm, unsigned long long mn)
+{
+  typedef float v4hi __attribute__ ((mode(V4HI)));
+
+  return (unsigned long long) __builtin_sh_media_MMULFXRP_W ((v4hi) mm,
+							     (v4hi) mn);
+}
+
+static __inline unsigned long long
+sh_media_MMULHI_WL (unsigned long long mm, unsigned long long mn)
+{
+  typedef float v4hi __attribute__ ((mode(V4HI)));
+
+  return (unsigned long long) __builtin_sh_media_MMULHI_WL ((v4hi) mm,
+							    (v4hi) mn);
+}
+
+static __inline unsigned long long
+sh_media_MMULLO_WL (unsigned long long mm, unsigned long long mn)
+{
+  typedef float v4hi __attribute__ ((mode(V4HI)));
+
+  return (unsigned long long) __builtin_sh_media_MMULLO_WL ((v4hi) mm,
+							    (v4hi) mn);
+}
+
+static __inline unsigned long long
+sh_media_MMULSUM_WQ (unsigned long long mm, unsigned long long mn,
+		     unsigned long long mw)
+{
+  typedef unsigned int uv4hi __attribute__ ((mode(V4HI)));
+
+  return __builtin_sh_media_MMULSUM_WQ ((uv4hi) mm, (uv4hi) mn, mw);
+}
+
+static __inline unsigned long long
+sh_media_MPERM_W (unsigned long long mm, unsigned int mn)
+{
+  typedef float v4hi __attribute__ ((mode(V4HI)));
+
+  return (unsigned long long) __builtin_sh_media_MPERM_W ((v4hi) mm, mn);
+}
+
+static __inline unsigned long long
+sh_media_MSAD_UBQ (unsigned long long mm, unsigned long long mn,
+		   unsigned long long mw)
+{
+  typedef unsigned int uv8qi __attribute__ ((mode(V8QI)));
+
+  return __builtin_sh_media_MSAD_UBQ ((uv8qi) mm, (uv8qi) mn, mw);
+}
+
+static __inline unsigned long long
+sh_media_MSHALDS_L (unsigned long long mm, unsigned int mn)
+{
+  typedef float v2si __attribute__ ((mode(V2SI)));
+
+  return (unsigned long long) __builtin_sh_media_MSHALDS_L ((v2si) mm, mn);
+}
+
+static __inline unsigned long long
+sh_media_MSHALDS_W (unsigned long long mm, unsigned int mn)
+{
+  typedef float v4hi __attribute__ ((mode(V4HI)));
+
+  return (unsigned long long) __builtin_sh_media_MSHALDS_W ((v4hi) mm, mn);
+}
+
+static __inline unsigned long long
+sh_media_MSHARD_L (unsigned long long mm, unsigned int mn)
+{
+  typedef float v2si __attribute__ ((mode(V2SI)));
+
+  return (unsigned long long) __builtin_ashrv2si3 ((v2si) mm, mn);
+}
+
+static __inline unsigned long long
+sh_media_MSHARD_W (unsigned long long mm, unsigned int mn)
+{
+  typedef float v4hi __attribute__ ((mode(V4HI)));
+
+  return (unsigned long long) __builtin_ashrv4hi3 ((v4hi) mm, mn);
+}
+
+#define sh_media_MSHARDS_Q __builtin_sh_media_MSHARDS_Q
+
+static __inline unsigned long long
+sh_media_MSHFHI_B (unsigned long long mm, unsigned long long mn)
+{
+  typedef float v8qi __attribute__ ((mode(V8QI)));
+
+  return (unsigned long long) __builtin_sh_media_MSHFHI_B ((v8qi) mm,
+							   (v8qi) mn);
+}
+
+static __inline unsigned long long
+sh_media_MSHFHI_L (unsigned long long mm, unsigned long long mn)
+{
+  typedef float v2si __attribute__ ((mode(V2SI)));
+
+  return (unsigned long long) __builtin_sh_media_MSHFHI_L ((v2si) mm,
+							   (v2si) mn);
+}
+
+static __inline unsigned long long
+sh_media_MSHFHI_W (unsigned long long mm, unsigned long long mn)
+{
+  typedef float v4hi __attribute__ ((mode(V4HI)));
+
+  return (unsigned long long) __builtin_sh_media_MSHFHI_W ((v4hi) mm,
+							   (v4hi) mn);
+}
+
+static __inline unsigned long long
+sh_media_MSHFLO_B (unsigned long long mm, unsigned long long mn)
+{
+  typedef float v8qi __attribute__ ((mode(V8QI)));
+
+  return (unsigned long long) __builtin_sh_media_MSHFLO_B ((v8qi) mm,
+							   (v8qi) mn);
+}
+
+static __inline unsigned long long
+sh_media_MSHFLO_L (unsigned long long mm, unsigned long long mn)
+{
+  typedef float v2si __attribute__ ((mode(V2SI)));
+
+  return (unsigned long long) __builtin_sh_media_MSHFLO_L ((v2si) mm,
+							   (v2si) mn);
+}
+
+static __inline unsigned long long
+sh_media_MSHFLO_W (unsigned long long mm, unsigned long long mn)
+{
+  typedef float v4hi __attribute__ ((mode(V4HI)));
+
+  return (unsigned long long) __builtin_sh_media_MSHFLO_W ((v4hi) mm,
+							   (v4hi) mn);
+}
+
+static __inline unsigned long long
+sh_media_MSHLLD_L (unsigned long long mm, unsigned int mn)
+{
+  typedef float v2si __attribute__ ((mode(V2SI)));
+
+  return (unsigned long long) __builtin_ashlv2si3 ((v2si) mm, mn);
+}
+
+static __inline unsigned long long
+sh_media_MSHLLD_W (unsigned long long mm, unsigned int mn)
+{
+  typedef float v4hi __attribute__ ((mode(V4HI)));
+
+  return (unsigned long long) __builtin_ashlv4hi3 ((v4hi) mm, mn);
+}
+
+static __inline unsigned long long
+sh_media_MSHLRD_L (unsigned long long mm, unsigned int mn)
+{
+  typedef float v2si __attribute__ ((mode(V2SI)));
+
+  return (unsigned long long) __builtin_lshrv2si3 ((v2si) mm, mn);
+}
+
+static __inline unsigned long long
+sh_media_MSHLRD_W (unsigned long long mm, unsigned int mn)
+{
+  typedef float v4hi __attribute__ ((mode(V4HI)));
+
+  return (unsigned long long) __builtin_lshrv4hi3 ((v4hi) mm, mn);
+}
+
+static __inline unsigned long long
+sh_media_MSUB_L (unsigned long long mm, unsigned long long mn)
+{
+  typedef float v2si __attribute__ ((mode(V2SI)));
+
+  return (unsigned long long) __builtin_subv2si3 ((v2si) mm, (v2si) mn);
+}
+
+static __inline unsigned long long
+sh_media_MSUB_W (unsigned long long mm, unsigned long long mn)
+{
+  typedef float v4hi __attribute__ ((mode(V4HI)));
+
+  return (unsigned long long) __builtin_subv4hi3 ((v4hi) mm, (v4hi) mn);
+}
+
+static __inline unsigned long long
+sh_media_MSUBS_L (unsigned long long mm, unsigned long long mn)
+{
+  typedef float v2si __attribute__ ((mode(V2SI)));
+
+  return (unsigned long long) __builtin_sssubv2si3 ((v2si) mm, (v2si) mn);
+}
+
+static __inline unsigned long long
+sh_media_MSUBS_UB (unsigned long long mm, unsigned long long mn)
+{
+  typedef float v8qi __attribute__ ((mode(V8QI)));
+
+  return (unsigned long long) __builtin_ussubv8qi3 ((v8qi) mm, (v8qi) mn);
+}
+
+static __inline unsigned long long
+sh_media_MSUBS_W (unsigned long long mm, unsigned long long mn)
+{
+  typedef float v4hi __attribute__ ((mode(V4HI)));
+
+  return (unsigned long long) __builtin_sssubv4hi3 ((v4hi) mm, (v4hi) mn);
+}
+
+#if ! __SH4_NOFPU__
+/* Floating-point Intrinsics */
+
+#define sh_media_FABS_D __builtin_fabs
+#define sh_media_FABS_S __builtin_fabsf
+#define sh_media_FCMPUN_D __builtin_isunordered
+#define sh_media_FCMPUN_S __builtin_isunordered
+
+static __inline float sh_media_FCOSA_S (float fg)
+{
+  union { int i; float f; } u;
+
+  u.f = fg;
+  return __builtin_sh_media_FCOSA_S (u.i);
+}
+
+static __inline float
+sh_media_FGETSCR (void)
+{ 
+  float f;
+
+  __asm volatile ("fgetscr %0" : "=f" (f));
+  return f;
+}
+
+static __inline float
+sh_media_FIPR_S (const void *fvg, const void *fvh)
+{
+  typedef float v4sf __attribute__ ((mode(V4SF)));
+  v4sf vg = *(v4sf*) fvg;
+  v4sf vh = *(v4sf*) fvh;
+
+  return __builtin_sh_media_FIPR_S (vg, vh);
+}
+
+#if 0
+/* This gives different results for -O0  */
+static __inline float
+sh_media_FMAC_S (float fg, float fh, float fq)
+{
+  return fg * fh + fq;
+}
+#else
+
+#define sh_media_FMAC_S __builtin_sh_media_FMAC_S
+#endif
+
+static __inline long long
+sh_media_FMOV_DQ (double dg)
+{
+  union { long long l; double d; } u;
+
+  u.d = dg;
+  return u.l;
+}
+
+static __inline float
+sh_media_FMOV_LS (int mm)
+{
+  union { int i; float f; } u;
+
+  u.i = mm;
+  return u.f;
+}
+
+static __inline double
+sh_media_FMOV_QD (long long mm)
+{
+  union { long long l; double d; } u;
+
+  u.l = mm;
+  return u.d;
+}
+
+static __inline int
+sh_media_FMOV_SL (float fg)
+{
+  union { int i; float f; } u;
+
+  u.f = fg;
+  return u.i;
+}
+
+static __inline void
+sh_media_FPUTSCR (float fg)
+{ 
+  __asm volatile ("fputscr %0" : : "f" (fg));
+}
+
+static __inline float sh_media_FSINA_S (float fg)
+{
+  union { int i; float f; } u;
+
+  u.f = fg;
+  return __builtin_sh_media_FSINA_S (u.i);
+}
+
+/* Can't use __builtin_sqrt / __builtin_sqrtf because they still implement
+   error handling unless -ffast-math is used.  */
+#define sh_media_FSQRT_D __builtin_sh_media_FSQRT_D
+#define sh_media_FSQRT_S __builtin_sh_media_FSQRT_S
+#define sh_media_FSRRA_S __builtin_sh_media_FSRRA_S
+
+static __inline void
+sh_media_FTRV_S (const void *mtrxg, const void *fvh, void *fvf)
+{
+  typedef float v16sf __attribute__ ((mode(V16SF)));
+  typedef float v4sf __attribute__ ((mode(V4SF)));
+  v16sf mtrx = *(v16sf*) mtrxg;
+  v4sf vh = *(v4sf*) fvh;
+
+  *(v4sf*) fvf = __builtin_sh_media_FTRV_S (mtrx, vh);
+}
+#endif /* ! __SH4_NOFPU__ */
+
+/* Not implemented here: Control and Configuration intrinsics.  */
+/* Misaligned Access Support intrinsics */
+
+static __inline unsigned long long
+sh_media_LDHI_L (void *p, int s)
+{
+  return __builtin_sh_media_LDHI_L ((char *)p + s);
+}
+
+static __inline unsigned long long
+sh_media_LDHI_Q (void *p, int s)
+{
+  return __builtin_sh_media_LDHI_Q ((char *)p + s);
+}
+
+static __inline unsigned long long
+sh_media_LDLO_L (void *p, int s)
+{
+  return __builtin_sh_media_LDLO_L ((char *)p + s);
+}
+
+static __inline unsigned long long
+sh_media_LDLO_Q (void *p, int s)
+{
+  return __builtin_sh_media_LDLO_Q ((char *)p + s);
+}
+
+static __inline void
+sh_media_STHI_L (void *p, int s, unsigned int mw)
+{
+  __builtin_sh_media_STHI_L ((char*)p + s, mw);
+}
+
+static __inline void
+sh_media_STHI_Q (void *p, int s, unsigned long long mw)
+{
+  __builtin_sh_media_STHI_Q ((char*)p + s, mw);
+}
+
+static __inline void
+sh_media_STLO_L (void *p, int s, unsigned int mw)
+{
+  __builtin_sh_media_STLO_L ((char*)p + s, mw);
+}
+
+static __inline void
+sh_media_STLO_Q (void *p, int s, unsigned long long mw)
+{
+  __builtin_sh_media_STLO_Q ((char*)p + s, mw);
+}
+
+/* Miscellaneous intrinsics */
+
+#define sh_media_NSB __builtin_sh_media_NSB
+
+static __inline unsigned long long
+sh_media_BYTEREV (unsigned long long mm)
+{
+  typedef float v8qi __attribute__ ((mode(V8QI)));
+
+  return (unsigned long long) __builtin_sh_media_BYTEREV ((v8qi) mm);
+}
+
+__inline__ static unsigned long long
+sh_media_CMVEQ (unsigned long long mm, unsigned long long mn, unsigned long long mw) __attribute__ ((always_inline));
+
+__inline__ static unsigned long long
+sh_media_CMVEQ (unsigned long long mm, unsigned long long mn, unsigned long long mw)
+{
+  return mm == 0 ? mn : mw;
+}
+
+__inline__ static unsigned long long
+sh_media_CMVNE (unsigned long long mm, unsigned long long mn, unsigned long long mw) __attribute__ ((always_inline));
+
+__inline__ static unsigned long long
+sh_media_CMVNE (unsigned long long mm, unsigned long long mn, unsigned long long mw)
+{
+  return mm != 0 ? mn : mw;
+}
+
+static __inline long long
+sh_media_ADDZ_L (unsigned int mm, unsigned int mn)
+{
+  return mm + mn;
+}
+
+/* NOP and Synchronization intrinsics not implemented here.  */
+
+static __inline__ void sh_media_PREFO(void *mm, int s)
+{
+  __builtin_sh_media_PREFO (mm + s, 0, 0);
+}
+
+/* Event Handling intrinsics not implemented here.  */
+
+/* Old asm stuff */
+
+static __inline__
+void
+sh_media_NOP (void)
+{
+  __asm__ ("nop" : :);
+}
+
+__inline__ static
+unsigned long long
+sh_media_SWAP_Q (void *mm, long long mn, unsigned long long mw)
+{
+  unsigned long long res;
+  unsigned long long *addr = (unsigned long long *)((char *)mm + mn);
+  __asm__ ("swap.q	%m1, %0" : "=r" (res), "+o" (*addr) : "0" (mw));
+  return res;
+}
+
+__inline__ static
+void     
+sh_media_SYNCI (void)
+{
+  __asm__ __volatile__ ("synci");
+}
+
+__inline__ static
+void     
+sh_media_SYNCO (void)
+{
+  __asm__ __volatile__ ("synco");
+}
+
+__inline__ static
+void
+sh_media_ALLOCO (void *mm, int s)
+{
+  __builtin_sh_media_ALLOCO (mm + s);
+}
+
+__inline__ static
+void
+sh_media_ICBI (void *mm, int s)
+{
+  __asm__ __volatile__ ("icbi	%m0" : : "o" (((char*)mm)[s]));
+}
+
+__inline__ static
+void
+sh_media_OCBI (void *mm, int s)
+{
+  __asm__ __volatile__ ("ocbi	%m0" : : "o" (((char*)mm)[s]));
+}
+
+__inline__ static
+void
+sh_media_OCBP (void *mm, int s)
+{
+  __asm__ __volatile__ ("ocbp	%m0" : : "o" (((char*)mm)[s]));
+}
+
+__inline__ static
+void
+sh_media_OCBWB (void *mm, int s)
+{
+  __asm__ __volatile__ ("ocbwb	%m0" : : "o" (((char*)mm)[s]));
+}
+
+__inline__ static
+void
+sh_media_PREFI (void *mm, int s)
+{
+  __asm__ __volatile__ ("prefi	%m0" : : "o" (((char*)mm)[s]));
+}
+
+__inline__ static
+void
+sh_media_BRK (void)
+{
+  __asm__ __volatile__ ("brk");
+}
+
+__inline__ static
+void
+sh_media_TRAPA (unsigned long long mm)
+{
+  __asm__ __volatile__ ("trapa	%%0" : : "r" (mm));
+}
+
+__inline__ static
+short         
+sh_media_unaligned_LD_W (void *p)
+{
+#if __LITTLE_ENDIAN__
+  return (((unsigned char *)p)[0]
+	  | (((short)((__signed__ char *)p)[1]) << 8));
+#else
+  return ((((short)((__signed__ char *)p)[0]) << 8)
+	  | ((unsigned char *)p)[1]);
+#endif
+}
+
+__inline__ static
+unsigned short
+sh_media_unaligned_LD_UW (void *p)
+{
+  unsigned char *addr = p;
+#if __LITTLE_ENDIAN__
+  return sh_media_MSHFLO_B (addr[0], addr[1]);
+#else
+  return sh_media_MSHFLO_B (addr[1], addr[0]);
+#endif
+}
+
+/* We don't use the sh_media_LD* functions here because that turned out
+   to impede constant propagation of the offsets into the ldhi / ldlo
+   instructions.  */
+__inline__ static
+int           
+sh_media_unaligned_LD_L (void *p)
+{
+#if __LITTLE_ENDIAN__
+  return (__builtin_sh_media_LDHI_L ((char *)p + 3)
+	  | __builtin_sh_media_LDLO_L (p));
+#else
+  return (__builtin_sh_media_LDLO_L ((char *)p + 3)
+	  | __builtin_sh_media_LDHI_L (p));
+#endif
+}
+
+__inline__ static
+long long     
+sh_media_unaligned_LD_Q (void *p)
+{
+#if __LITTLE_ENDIAN__
+  return (__builtin_sh_media_LDHI_Q ((char *)p + 7)
+	  | __builtin_sh_media_LDLO_Q (p));
+#else
+  return (__builtin_sh_media_LDLO_Q ((char *)p + 7)
+	  | __builtin_sh_media_LDHI_Q (p));
+#endif
+}
+
+__inline__ static
+void
+sh_media_unaligned_ST_W (void *p, unsigned int k)
+{
+  char *addr = p;
+#if __LITTLE_ENDIAN__
+  addr[0] = k;
+  addr[1] = k >> 8;
+#else
+  addr[1] = k;
+  addr[0] = k >> 8;
+#endif
+}
+
+/* We don't use the sh_media_ST* functions here because that turned out
+   to impede constant propagation of the offsets into the ldhi / ldlo
+   instructions.  */
+__inline__ static
+void
+sh_media_unaligned_ST_L (void *p, unsigned int k)
+{
+#if __LITTLE_ENDIAN__
+  __builtin_sh_media_STHI_L (p + 3, k);
+  __builtin_sh_media_STLO_L (p, k);
+#else
+  __builtin_sh_media_STLO_L (p + 3, k);
+  __builtin_sh_media_STHI_L (p, k);
+#endif
+}
+
+__inline__ static
+void
+sh_media_unaligned_ST_Q (void *p, unsigned long long k)
+{
+#if __LITTLE_ENDIAN__
+  __builtin_sh_media_STHI_Q (p + 7, k);
+  __builtin_sh_media_STLO_Q (p, k);
+#else
+  __builtin_sh_media_STLO_Q (p + 7, k);
+  __builtin_sh_media_STHI_Q (p, k);
+#endif
+}
+
+#if ! __SH4_NOFPU__
+__inline__ static
+void
+sh_media_FVCOPY_S (const void *fvg, void *fvf)
+{
+  const __GCC_FV *g = fvg;
+  __GCC_FV *f = fvf;
+  *f = *g;
+}
+
+__inline__ static
+void
+sh_media_FVADD_S (const void *fvg, const void *fvh, void *fvf)
+{
+  const float *g = fvg, *h = fvh;
+  float *f = fvf;
+#if 1
+  int i;
+
+  for (i = 0; i < 4; i++)
+    f[i] = g[i] + h[i];
+#else
+  f[0] = g[0] + h[0];
+  f[1] = g[1] + h[1];
+  f[2] = g[2] + h[2];
+  f[3] = g[3] + h[3];
+#endif
+}
+
+__inline__ static
+void
+sh_media_FVSUB_S (const void *fvg, const void *fvh, void *fvf)
+{
+  const float *g = fvg, *h = fvh;
+  float *f = fvf;
+#if 1
+  int i;
+
+  for (i = 0; i < 4; i++)
+    f[i] = g[i] - h[i];
+#else
+  f[0] = g[0] - h[0];
+  f[1] = g[1] - h[1];
+  f[2] = g[2] - h[2];
+  f[3] = g[3] - h[3];
+#endif
+}
+
+__inline__ static
+void
+sh_media_FMTRXCOPY_S (const void *mtrxg, void *mtrxf)
+{
+  const __GCC_MTRX *g = mtrxg;
+  __GCC_MTRX *f = mtrxf;
+  *f = *g;
+}
+
+__inline__ static
+void
+sh_media_FMTRXADD_S (const void *mtrxg, const void *mtrxh, void *mtrxf)
+{
+  const __GCC_FV *g = mtrxg, *h = mtrxh;
+  __GCC_FV *f = mtrxf;
+#if 1
+  int i;
+
+  for (i = 0; i < 4; i++)
+    sh_media_FVADD_S (&g[i], &h[i], &f[i]);
+#else
+  sh_media_FVADD_S (&g[0], &h[0], &f[0]);
+  sh_media_FVADD_S (&g[1], &h[1], &f[1]);
+  sh_media_FVADD_S (&g[2], &h[2], &f[2]);
+  sh_media_FVADD_S (&g[3], &h[3], &f[3]);
+#endif
+}
+
+__inline__ static
+void
+sh_media_FMTRXSUB_S (const void *mtrxg, const void *mtrxh, void *mtrxf)
+{
+  const __GCC_FV *g = mtrxg, *h = mtrxh;
+  __GCC_FV *f = mtrxf;
+#if 1
+  int i;
+
+  for (i = 0; i < 4; i++)
+    sh_media_FVSUB_S (&g[i], &h[i], &f[i]);
+#else
+  sh_media_FVSUB_S (&g[0], &h[0], &f[0]);
+  sh_media_FVSUB_S (&g[1], &h[1], &f[1]);
+  sh_media_FVSUB_S (&g[2], &h[2], &f[2]);
+  sh_media_FVSUB_S (&g[3], &h[3], &f[3]);
+#endif
+}
+
+__inline__ static
+void
+sh_media_FTRVADD_S (const void *mtrxg, const void *fvh, const void *fvi,
+		    void *fvf)
+{
+  sh_media_FTRV_S (mtrxg, fvh, fvf);
+  sh_media_FVADD_S (fvf, fvi, fvf);
+}
+
+__inline__ static
+void
+sh_media_FTRVSUB_S (const void *mtrxg, const void *fvh, const void *fvi,
+		    void *fvf)
+{
+  sh_media_FTRV_S (mtrxg, fvh, fvf);
+  sh_media_FVSUB_S (fvf, fvi, fvf);
+}
+
+__inline__ static
+void
+sh_media_FMTRXMUL_S (const void *mtrxg, const void *mtrxh, void *mtrxf)
+{
+  const __GCC_FV *g = mtrxg;
+  __GCC_FV *f = mtrxf;
+#if 1
+  int j;
+
+  for (j = 0; j < 4; j++)
+    sh_media_FTRV_S (mtrxh, &g[j], &f[j]);
+#else
+  sh_media_FTRV_S (mtrxh, &g[0], &f[0]);
+  sh_media_FTRV_S (mtrxh, &g[1], &f[1]);
+  sh_media_FTRV_S (mtrxh, &g[2], &f[2]);
+  sh_media_FTRV_S (mtrxh, &g[3], &f[3]);
+#endif
+}
+
+__inline__ static
+void
+sh_media_FMTRXMULADD_S (const void *mtrxg, const void *mtrxh,
+			const void *mtrxi, void *mtrxf)
+{
+  const __GCC_FV *g = mtrxg, *i = mtrxi;
+  __GCC_FV *f = mtrxf;
+#if 1
+  int j;
+
+  for (j = 0; j < 4; j++)
+    sh_media_FTRVADD_S (mtrxh, &g[j], &i[j], &f[j]);
+#else
+  sh_media_FTRVADD_S (mtrxh, &g[0], &i[0], &f[0]);
+  sh_media_FTRVADD_S (mtrxh, &g[1], &i[1], &f[1]);
+  sh_media_FTRVADD_S (mtrxh, &g[2], &i[2], &f[2]);
+  sh_media_FTRVADD_S (mtrxh, &g[3], &i[3], &f[3]);
+#endif
+}
+
+__inline__ static
+void
+sh_media_FMTRXMULSUB_S (const void *mtrxg, const void *mtrxh,
+			const void *mtrxi, void *mtrxf)
+{
+  const __GCC_FV *g = mtrxg, *i = mtrxi;
+  __GCC_FV *f = mtrxf;
+#if 1
+  int j;
+
+  for (j = 0; j < 4; j++)
+    sh_media_FTRVSUB_S (mtrxh, &g[j], &i[j], &f[j]);
+#else
+  sh_media_FTRVSUB_S (mtrxh, &g[0], &i[0], &f[0]);
+  sh_media_FTRVSUB_S (mtrxh, &g[1], &i[1], &f[1]);
+  sh_media_FTRVSUB_S (mtrxh, &g[2], &i[2], &f[2]);
+  sh_media_FTRVSUB_S (mtrxh, &g[3], &i[3], &f[3]);
+#endif
+}
+#endif /* ! __SH4_NOFPU__ */
+
+#endif /* __SHMEDIA__ */
+
+#endif /* _USHMEDIA_H */
diff -u -r -N gcc-7.3.0/gcc/config.gcc gcc-7.3.0_patch/gcc/config.gcc
--- gcc-7.3.0/gcc/config.gcc	2018-01-08 14:39:11.000000000 +0100
+++ gcc-7.3.0_patch/gcc/config.gcc	2018-12-28 21:44:31.095550695 +0100
@@ -2692,6 +2692,39 @@
 	case ${with_endian} in
 	little*)	tm_file="sh/little.h ${tm_file}" ;;
 	esac
+
+	case ${with_builtin_trap} in
+	"")
+		case ${target} in
+		sh*-*-linux*)
+		  tm_defines="$tm_defines SH_BUILTIN_TRAP_DEFAULT_TRAPA=0x54"
+		esac
+		;;
+	libcall)
+		tm_defines="$tm_defines SH_BUILTIN_TRAP_DEFAULT_LIBCALL=1"
+		;;
+	trapa-[0123456789]*)
+		trapa_value=`echo $with_builtin_trap | tr -d -c 0-9`
+
+		if [ $trapa_value -gt 255 ]; then
+		  echo "Invalid trapa number in --with-builtin-trap=$with_builtin_trap"
+		  exit 1
+		fi
+
+		tm_defines="$tm_defines SH_BUILTIN_TRAP_DEFAULT_TRAPA=$trapa_value"
+		;;
+	*)
+		echo "Invalid builtin trap handler in --with-builtin-trap=$with_builtin_trap"
+		exit 1
+	esac
+
+	if test x$enable_sh4_trapa_sleep_bug = xyes; then
+	  tm_defines="$tm_defines SH4_TRAPA_SLEEP_BUG_DEFAULT=1"
+	fi
+	if test x$enable_sh4_trapa_sleep_bug = xno; then
+	  tm_defines="$tm_defines SH4_TRAPA_SLEEP_BUG_DEFAULT=0"
+	fi
+
 	tm_file="${tm_file} dbxelf.h elfos.h sh/elf.h"
 	case ${target} in
 	sh*-*-linux*)	tmake_file="${tmake_file} sh/t-linux"
